> Teacher: Liu Qing  
E-mail: liuqing@ynu.edu.cn

## Week 1
---
### 1.1 What is a compiling program?
#### Programming language
- program: a set of instructions
- machine language: consists of 0 and 1
- assembly language: pseudo code with symbols
- high-level language: natural-like language and mathematical formula
> FORTRAN: **For**mula **Tran**slation, the first high-level language

#### Compiling Terminology
- Compiler: translate high-level program to target program
- Running System: sub-programs required when target program is running
- Compiling System: __Compiler__ + __Running System__
- Interpretor: compiling while running

#### Translator
Language A --> Translator --> equivalent Language B

#### Compiler
high-level language A --> Compiler --> equivalent assembly language or machine language

### 1.2 Compiling Process
#### 6阶段（8部分）
1. 词法分析
   - 这个阶段的任务是从左到右读入源程序，对构成源程序的字符流进行扫描和分解，从而识别出一个个单词（也称单词符号和TOKEN）
1. 语法分析
   - 语法分析的任务是在语法分析的基础上将单词序列分解成各类语法短语（也称语法单位、语法成分、语法范畴），如“程序”，“语句”，“表达式”等等。
   - 语法分析所依据的是语言的语法规则，即描述程序结构的规则。通过语法分析确定整个输入串是否构成一个语法上正确的程序。
1. 语义分析
   - 依据语言的语义规则，对语法分析得到的语法结构分析其含义以及应进行的运算，审查源程序中有无语义错误，为代码生成阶段收集类型信息。
1. 中间代码生成
   - 某些编译程序将源程序转变成一种内部表示形式，叫做中间代码。
   - 所谓“中间代码”是一种结构简单，含义明确的记号系统，可以设计为多种多样的形式。
   - 中间代码设计原则：容易生成、容易翻译成目标代码（举例：四元式）
1. 代码优化
   - 对前阶段产生的中间代码序列进行变换或改造。目的是使生成的目标代码更高效，即省时间省空间。
1. 目标代码生成
   - 将中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码。它的工作与硬件系统结构和指令含义有关。

#### 另外两个重要的工作：
1. 表格管理
   - 编译过程中源程序的各种信息被保留在种种不同的表格里，各阶段工作都涉及到构造、查找或更新有关的表格，因此需要表格管理。
1. 出错处理
   - 错误产生时，编译程序应报告错误的性质和发生地点，并且将错误所造成的影响限制在尽可能小的范围内，使得源程序的其余部分能继续被编译下去。
   - 有些编译程序还能自动校正错误，这些工作被称为错误处理。

### 1.3 编译阶段的组合
#### 前端和后端
- 前端：其工作依赖于源程序而与目标机无关
- 后端：其工作依赖于目标机和中间代码而与源程序无关
- 前后端可以自由组合，实现丰富的功能

#### 遍（Pass）
- 遍（Pass），指对源程序或源程序的中间形式从头到尾扫视并完成规定任务的过程。
- 每一遍扫视可完成一个阶段或多个阶段的功能。
- 一个编译程序需要分成几遍，应视**语言要求**和**机器情况**而定。
  - 一遍的编译程序：以语法分析为核心，反复调用词法分析和语义分析子程序。
  - 多遍的编译程序：每一遍执行一个阶段的任务。

### 1.4 编译技术和软件工具
- 语言的结构化编辑器
- 语言程序的调试工具
- 语言程序的测试工具
- 高级语言之间的转换工具
- 并行编译技术

### 1.5 程序设计语言范型
- 强制（命令）式语言
  - 也称过程式语言
  - C, FORTRAN
- 函数式语言
- 基于规则的语言
  - 也称逻辑程序设计语言
  - PROLOG
- 面向对象的语言

## 2 文法和语言
---
### 2.1 符号和符号串
字母表：元素的有穷非空集合
- 如PASCAL语言的字母表是由字母、数字、若干专用符号及BEGIN/IF之类的保留字组成。

符号串：由字母表中的符号组成的任何有穷序列
- 如PASCAL语言程序是PASCAL语言字母表上的一个符号串，不含任何符号的符号串为空符号串，记为**ε**

符号串的头尾，固有头和固有尾

符号串的运算：
- 连接
- 方幂
- 乘积（笛卡儿积）
- 符号串集合的正闭包A+
- 符号串集合的闭包A*
### 2.2 文法和语言的形式定义
文法是描述语言的语法结构的规则
1. 文法的形式定义：四元组G=（Vn, Vt, P, S）
   - Vn为非终结符号集：大写字母或<>括号表示
   - Vt为终结符号集：小写字母或不带<>的符号
   - 字母表V = Vn U Vt，称为文法G的字母表
   - P为产生式（规则）的集合
     - α -> β: α定义为β
     - 其中α ∈ V+, β ∈ V*
   - S称作识别符号或开始符号（规约和推导），是一个非终结符号
> 有文法G=(VN, VT, P, S)，VN={S}, VT={0, 1}, P={S->0S1, S->01}  
> 也可表示为：G: S->0S1, S->01  
> 约定第一条产生式的左部是文法的开始符号  
2. 推导的概念
   - 编程是推导，编译器校验是规约
3. 句型和句子的定义
   - 如果符号串x是从识别符号推导出来的，则称x是文法G的句型
   - 如果x仅由终结符构成，则称x是文法G的句子
4. 语言的定义
   - 文法G产生的语言记为L(G)，它是文法G产生的全部句子的集合
5. 文法等价定义
   - 若L(G1) = L(G2)，则称文法G1和文法G2是等价的

### 2.3 文法的类型
- 文法的定义和记号：四元组G=(VN, VT, P, S)
  - 0型文法：定义0型语言，对应Turing机
  - 1型文法（上下文有关文法CSG）：定义1型语言，对应线性限界自动机
  - 2型文法（上下文无关文法CFG）：定义2型语言，对应非确定下推自动机
  - 3型文法（正规语言）：定义3型语言，对应有限自动机
- 文法的不同在于对产生式施加不同的限制

### 2.4 上下文无关文法及其语法树
1. 用上下文无关文法描述程序设计语言的语法结构
   - 同一非终结符出现在产生式的左右两边，可以定义无限的语言

2. 语法树定义
   - 给定文法G={Vn, Vt, P, S}，对于G的任何句型都能构造与之关联的语法树（推导树）
   - 这棵树满足下列4个条件：
     1. 每个结点都有一个标记，此标记是V的一个符号
     2. 根的标记是S
     3. 叶子节点内的标记属于V
     4. 树可从根节点推导
   - 语法树是描述上下文无关文法的句型推导的直观方法

3. 由语法树定义句型
   - 在一棵树生长过程中的任何时刻，所有那些端末节点自左至右的排练，就是一个句型

4. 最左、最右推导
   - 在推导的任何一步α推出β
   - 如果都是对α中最左非终结符进行，称为最左推导
   - ...最右...最右...
   - 最右推导也成为规范推导，所得句型称为规范句型，对应的最左规约称为规范规约

5. 文法的二义性
   - 如果一个文法存在某个句型对应两棵不同的语法树，则说这个文法是二义的
   - 或者说，若一个文法中存在某个句型，它有两个不同的最左（最右）推导，则这个文法是二义的
   - 排除二义性的两种方法：
     1. 在语义上加限制（优先级）
     2. 重新构造一个无二义性的文法

### 2.5 句型的分析
- 指识别一个符号串是否为某文法的句型，是某个推导的构造过程
- 句型分析的方法：top->down / bottom->up
  - 自上而下的分析方法就是从文法的开始符号出发，反复使用各种产生式，寻找**匹配**于输入符号串的推导
  - 自下而上的分析法就是从输入符号串开始，逐步进行“规约”，直至规约到文法的开始符号
  - 并不是句型中的“串”只要是产生式的右部就可以规约
- 短语、句柄的定义
  - 短语：由产生式而来的是短语，一步推导而来的是直接短语或简单短语
  - 句柄：一个句型的最左直接短语称为该句型的句柄

### 2.6 有关文法实用中的一些说明
1. 有关文法的实用限制
- 限制文法中含有如下规则：
  1. 有害规则
  2. 多余规则
  3. 无用规则 即**单独定义的**单产生式
- 为保证文法G的任一非终结符A在推导中出现，必须满足：
  1. A必须在某句型中出现
  2. 必须能够从A推导出终结符号串t

2. 有关文法的二义性
- 无二义文法：如果一个文法所产生的每一个句子都仅有一颗语法树，则称此文法为无二义性的
- 二义性的判定：上下文无关文法是否具有二义性是不可判定的
- 一个文法既有左递归又有有递归是导致二义性的常见原因

3. 文法的化简和改造
   - 无用符号和无用产生式的删除
   - 空串ε产生式的消除
   - 单产生式的消除
   - 左递归的消除

### 2.7 扩展的BNF - EBNF
- Backus-Naur Form
- 语法说明：
  - <> 表示语法构造成分
  - ::= 表示左部由右部定义
  - {} 表示内部内容可重复，默认为0 ~ ∞次

> I-N规则：字母i到n被认为是整形变量

## 3 词法分析

### 3.1 词法分析程序的输出形式
- 一般情况下，常将词法分析程序设计成一个子程序
- TOKEN是一个程序设计语言的基本语法符号，一般分为5种：
  1. 基本字，也称关键字，如var/begin
  2. 标识符，用来表示各种名字，如常量名、变量名和过程名
  3. 常数，各种类型的常数，如25、3.14、TRUE等
  4. 运算符，如+、-、*、/
  5. 界符，如逗号、分号、括号等
- 词法分析程序输出的单词符号采用二元式：（单词种别，单词自身的值）
  1. 单词种别：单词的种别式语法分析需要的信息，用整数码或助记符等表示
  2. 单词自身的值：是编译其他阶段需要的信息，一般用单词自身表示，若单词类别仅表示一个单词，可不用单词自身的值

### 3.2 单词的描述工具
- 程序设计语言中的单词（TOKEN）是基本语法符号
- 单词符号的语法可以用有效的工具描述
- 正规文法：3型文法，描述的是Vt*上的正规集
- 正规式：字母表+基本操作

### 3.3 有穷自动机
- 也称有限自动机，可以准确识别正规集，即识别正规文法所定义的语言和正规式所表示的集合
- 有穷自动机分为两类：
  - 确定有穷自动机DFA - Deterministic Finite Automata
  - 不确定有穷自动机NFA - Nondeterministic Finite Automata